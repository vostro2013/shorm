/**
 * Autogenerated by Avro
 * <p>
 * DO NOT EDIT DIRECTLY
 */
package com.xiaowen.shorm.turorial.dao.entity;

import com.xiaowen.shorm.persistency.Dirtyable;
import com.xiaowen.shorm.persistency.Persistent;
import com.xiaowen.shorm.persistency.impl.DirtyMapWrapper;
import com.xiaowen.shorm.persistency.impl.PersistentBase;
import org.apache.avro.AvroRuntimeException;
import org.apache.avro.Schema;
import org.apache.avro.data.RecordBuilder;
import org.apache.avro.specific.SpecificRecord;
import org.apache.avro.specific.SpecificRecordBuilderBase;

import java.nio.ByteBuffer;
import java.util.Map;

public class Metadata extends PersistentBase implements SpecificRecord, Persistent {
    public static final Schema SCHEMA$ = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Metadata\",\"namespace\":\"com.xiaowen.shorm.turorial.entity\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"default\":0},{\"name\":\"data\",\"type\":{\"type\":\"map\",\"values\":\"string\"},\"default\":null}]}");
    private static final long serialVersionUID = -4490362841214952327L;

    /**
     * Enum containing all data bean's fields.
     */
    public static enum Field {
        VERSION(0, "version"),
        DATA(1, "data"),;
        /**
         * Field's index.
         */
        private int index;

        /**
         * Field's name.
         */
        private String name;

        /**
         * Field's constructor
         *
         * @param index field's index.
         * @param name field's name.
         */
        Field(int index, String name) {
            this.index = index;
            this.name = name;
        }

        /**
         * Gets field's index.
         *
         * @return int field's index.
         */
        public int getIndex() {
            return index;
        }

        /**
         * Gets field's name.
         *
         * @return String field's name.
         */
        public String getName() {
            return name;
        }

        /**
         * Gets field's attributes to string.
         *
         * @return String field's attributes to string.
         */
        @Override
        public String toString() {
            return name;
        }
    }

    ;

    public static final String[] _ALL_FIELDS = {
            "version",
            "data",
    };

    /**
     * Gets the total field count.
     *
     * @return int field count
     */
    public int getFieldsCount() {
        return Metadata._ALL_FIELDS.length;
    }

    private int version;
    private Map<CharSequence, CharSequence> data;


    @Override
    public Schema getSchema() {
        return SCHEMA$;
    }

    // Used by DatumWriter.  Applications should not call.
    @Override
    public Object get(int field$) {
        switch (field$) {
            case 0:
                return version;
            case 1:
                return data;
            default:
                throw new AvroRuntimeException("Bad index");
        }
    }

    // Used by DatumReader.  Applications should not call.
    @SuppressWarnings(value = "unchecked")
    @Override
    public void put(int field$, Object value) {
        switch (field$) {
            case 0:
                version = (Integer) (value);
                break;
            case 1:
                data = (Map<CharSequence, CharSequence>) ((value instanceof Dirtyable) ? value : new DirtyMapWrapper((Map) value));
                break;
            default:
                throw new AvroRuntimeException("Bad index");
        }
    }

    /**
     * Gets the value of the 'version' field.
     */
    public Integer getVersion() {
        return version;
    }

    /**
     * Sets the value of the 'version' field.
     *
     * @param value the value to set.
     */
    public void setVersion(Integer value) {
        this.version = value;
        setDirty(0);
    }

    /**
     * Checks the dirty status of the 'version' field. A field is dirty if it represents a change that has not yet been written to the database.
     */
    public boolean isVersionDirty() {
        return isDirty(0);
    }

    /**
     * Gets the value of the 'data' field.
     */
    public Map<CharSequence, CharSequence> getData() {
        return data;
    }

    /**
     * Sets the value of the 'data' field.
     *
     * @param value the value to set.
     */
    public void setData(Map<CharSequence, CharSequence> value) {
        this.data = (value instanceof Dirtyable) ? value : new DirtyMapWrapper(value);
        setDirty(1);
    }

    /**
     * Checks the dirty status of the 'data' field. A field is dirty if it represents a change that has not yet been written to the database.
     */
    public boolean isDataDirty() {
        return isDirty(1);
    }

    /**
     * Creates a new Metadata RecordBuilder
     */
    public static Metadata.Builder newBuilder() {
        return new Metadata.Builder();
    }

    /**
     * Creates a new Metadata RecordBuilder by copying an existing Builder
     */
    public static Metadata.Builder newBuilder(Metadata.Builder other) {
        return new Metadata.Builder(other);
    }

    /**
     * Creates a new Metadata RecordBuilder by copying an existing Metadata instance
     */
    public static Metadata.Builder newBuilder(Metadata other) {
        return new Metadata.Builder(other);
    }

    private static ByteBuffer deepCopyToReadOnlyBuffer(ByteBuffer input) {
        ByteBuffer copy = ByteBuffer.allocate(input.capacity());
        int position = input.position();
        input.reset();
        int mark = input.position();
        int limit = input.limit();
        input.rewind();
        input.limit(input.capacity());
        copy.put(input);
        input.rewind();
        copy.rewind();
        input.position(mark);
        input.mark();
        copy.position(mark);
        copy.mark();
        input.position(position);
        copy.position(position);
        input.limit(limit);
        copy.limit(limit);
        return copy.asReadOnlyBuffer();
    }

    /**
     * RecordBuilder for Metadata instances.
     */
    public static class Builder extends SpecificRecordBuilderBase<Metadata> implements RecordBuilder<Metadata> {
        private int version;
        private Map<CharSequence, CharSequence> data;

        /**
         * Creates a new Builder
         */
        private Builder() {
            super(Metadata.SCHEMA$);
        }

        /**
         * Creates a Builder by copying an existing Builder
         */
        private Builder(Metadata.Builder other) {
            super(other);
        }

        /**
         * Creates a Builder by copying an existing Metadata instance
         */
        private Builder(Metadata other) {
            super(Metadata.SCHEMA$);
            if (isValidValue(fields()[0], other.version)) {
                this.version = (Integer) data().deepCopy(fields()[0].schema(), other.version);
                fieldSetFlags()[0] = true;
            }
            if (isValidValue(fields()[1], other.data)) {
                this.data = (Map<CharSequence, CharSequence>) data().deepCopy(fields()[1].schema(), other.data);
                fieldSetFlags()[1] = true;
            }
        }


        /**
         * Gets the value of the 'version' field
         */
        public Integer getVersion() {
            return version;
        }

        /**
         * Sets the value of the 'version' field
         */
        public Metadata.Builder setVersion(int value) {
            validate(fields()[0], value);
            this.version = value;
            fieldSetFlags()[0] = true;
            return this;
        }

        /**
         * Checks whether the 'version' field has been set
         */
        public boolean hasVersion() {
            return fieldSetFlags()[0];
        }

        /**
         * Clears the value of the 'version' field
         */
        public Metadata.Builder clearVersion() {
            fieldSetFlags()[0] = false;
            return this;
        }

        /**
         * Gets the value of the 'data' field
         */
        public Map<CharSequence, CharSequence> getData() {
            return data;
        }

        /**
         * Sets the value of the 'data' field
         */
        public Metadata.Builder setData(Map<CharSequence, CharSequence> value) {
            validate(fields()[1], value);
            this.data = value;
            fieldSetFlags()[1] = true;
            return this;
        }

        /**
         * Checks whether the 'data' field has been set
         */
        public boolean hasData() {
            return fieldSetFlags()[1];
        }

        /**
         * Clears the value of the 'data' field
         */
        public Metadata.Builder clearData() {
            data = null;
            fieldSetFlags()[1] = false;
            return this;
        }

        public Metadata build() {
            try {
                Metadata record = new Metadata();
                record.version = fieldSetFlags()[0] ? this.version : (Integer) defaultValue(fields()[0]);
                record.data = fieldSetFlags()[1] ? this.data : (Map<CharSequence, CharSequence>) new DirtyMapWrapper((java.util.Map) defaultValue(fields()[1]));
                return record;
            } catch (Exception e) {
                throw new AvroRuntimeException(e);
            }
        }
    }

    public Metadata newInstance() {
        return newBuilder().build();
    }
}